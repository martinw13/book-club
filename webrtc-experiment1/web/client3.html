<!DOCTYPE html>
<html>
<head>
	    <script src="/socket.io/socket.io.js"></script>
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

</head>

<body>

    <div>your socket id: <span id="localsocketid"></span></div>
    <br>
    <div id="userlist"></div>
    <br>

    <video id="localVideo" playsinline autoplay muted style="width:200px; height:100px; border: solid 3px green;"></video>
    <video id="remoteVideo" playsinline autoplay  style="width:200px; height:100px; border: solid 3px red;"></video>

    <button type="button" id="connectbutton">connect</button>

</body>


<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
<script>
	const {
		RTCPeerConnection,
		RTCSessionDescription
	} = window;

	var userlist = [];
	var localsocketid = null;
	var localStream;
	var localVideo = document.getElementById('localVideo');
	var remoteVideo = document.getElementById('remoteVideo');
	var socket = null;

	// this is temporary
	var rpcOut = null;
	var remotesocketid = null;
	var rpcIn = null;


	function initlocal() {
		console.log("init socket");
		socket = io();
		// got user list from server, update local stuff
		socket.on("user-list", (users) => {
			updatelocalsocketid(socket);
			updateusers(users);
		});

		// the other client sent us an offer
		socket.on("relay-offer", (data) => {
			console.log("got an offer from other client: ",data);
			rpcIn = new RTCPeerConnection();
			rpcIn.setRemoteDescription(data.offer);
			rpcIn.addEventListener('track', gotRemoteStream);
		});

		// other client sent us an ice candidate
		socket.on("send-ice-candidate", (data) => {
			console.log(`ICE candidate:\n${data.icecandidate}`);
			try {
				rpcIn.addIceCandidate(data.icecandidate);
			} catch (e) {
				console.log("addIceCandidate error: ",e);
			}
		});

		$("#connectbutton").click(connectToFirstRemotePeer);
	}

	function gotRemoteStream(e) {
      console.log('received remote stream');
	  if (remoteVideo.srcObject !== e.streams[0]) {
	    remoteVideo.srcObject = e.streams[0];
        console.log('connected remote stream to local view');
	  }
	}



	function connectToFirstRemotePeer() {
		console.log("connectToFirstRemotePeer");

		// choose the first socketid in the userlist thats not us.  this is a hack, temporary
		remotesocketid = userlist.find( socketid => socketid != localsocketid );
		console.log("remotesocketid: ",remotesocketid);

		rpcOut = new RTCPeerConnection();
		// hook the streams from our local input to the outbound peer connection
		localStream.getTracks().forEach(track => rpcOut.addTrack(track, localStream)); 
		console.log("added local stream to rpcout");

		// when our outbound peer connection generates ice candidates, send them to the other client
		rpcOut.addEventListener('icecandidate', e => onIceCandidateEvent(e) );
		rpcOut.addEventListener('iceconnectionstatechange', e => onIceStateChange(e, rpcOut));
		console.log("added ice listeners to rpcout");

		// create offer and send it to the remote peer
		const offerOptions = {
		  offerToReceiveAudio: 1,
		  offerToReceiveVideo: 1
		};
		var theoffer = null;
	    rpcOut.createOffer(offerOptions).then(function(offer) {
			console.log("creating offer on rpcout");
	    	theoffer = offer;
			return rpcOut.setLocalDescription(offer);
		}).then(function() {
			console.log("sending offer for rpcout");
			socket.emit("relay-offer", {
				targetsocketid: remotesocketid,
				offer: theoffer
			});
		});
	}

	function onIceCandidateEvent(event) {
		console.log("sending ICE candidate event ", event.candidate);
		// bounce off server back to remote peer
		socket.emit("send-ice-candidate", {
			targetsocketid: remotesocketid,
			icecandidate: event.candidate
		});
	}

	function onIceStateChange(event, peerconnection) {
	    console.log(`ICE state: ${peerconnection.iceConnectionState}`);
	    console.log('ICE state change event: ', event);
	}




	function updatelocalsocketid(socket) {
		localsocketid = socket.id;
		document.getElementById("localsocketid").innerHTML = localsocketid;
	}

	function updateusers(users) {
		console.log("updateusers: ",users);
		// used to auto-connect here
		userlist = users;
		$("#userlist").html(JSON.stringify(userlist));
	}

	async function initLocalVideo() {
	  console.log('getting local stream');
	  try {
	    const stream = await navigator.mediaDevices.getUserMedia({audio: true, video: true});
	    console.log('got local stream');
	    localVideo.srcObject = stream;
	    localStream = stream;

	  } catch (e) {
	    alert(`getUserMedia() error: ${e.name}`);
	  }
	}

	initlocal();
	initLocalVideo();


	/*

	let localStream;
	const localVideo = document.getElementById('localVideo');
	const remoteVideo = document.getElementById('remoteVideo');
	var peerconn = new RTCPeerConnection();
	var remotepeerconn = new RTCPeerConnection();
	var remotesocketid = null; // temporary

	console.log("init socket");
	var socket = io();

	socket.on("user-list", (users) => {
		updatelocalsocketid(socket);
		updateusers(users);
	});

	// some other client requested our rtc
	socket.on("request-offer", (data) => {
		console.log("request-offer: ");
		// create offer and send it back
		const offerOptions = {
		  offerToReceiveAudio: 1,
		  offerToReceiveVideo: 1
		};
		var theoffer = null
		remotesocketid = data.requestingsocketid;
	    peerconn.createOffer(offerOptions).then(function(offer) {
	    	theoffer = offer;
			return peerconn.setLocalDescription(offer);
		}).then(function() {
			socket.emit("relay-offer", {
				targetsocketid: data.requestingsocketid,
				offer: theoffer
			});
		});
	});

	// other client sent us an ice candidate
	socket.on("send-ice-candidate", (data) => {
		console.log(`ICE candidate:\n${data.icecandidate}`);
		try {
			remotepeerconn.addIceCandidate(data.icecandidate);
		} catch (e) {
			console.log("addIceCandidate error: ",e);
		}
	});
	
	// the other client sent us back an offer
	socket.on("relay-offer", (data) => {
		console.log("relay-offer: ",data);
		remotepeerconn.addEventListener('track', gotRemoteStream);
		remotepeerconn.setRemoteDescription(data.offer);
	});
	
	function gotRemoteStream(e) {
	  if (remoteVideo.srcObject !== e.streams[0]) {
	    remoteVideo.srcObject = e.streams[0];
	    console.log('received remote stream');
	  }
	}

	function updatelocalsocketid(socket) {
		localsocketid = socket.id;
		document.getElementById("localsocketid").innerHTML = localsocketid;
	}

	function updateusers(users) {
		console.log("updateusers: ",users);
		for (var i=0; i < users.length; i++) {
			var socketid = users[i];
			if (socketid != localsocketid && userlist.indexOf(socketid) == -1) {
				// request rtc offer for new friend
				setTimeout(function() {
					socket.emit("request-offer", {targetsocketid: socketid});
				}, 100);
			}
		}
		userlist = users;
		$("#userlist").html(JSON.stringify(userlist));
	}

	async function startRTC() {
	  console.log('getting local stream');
	  try {
	    const stream = await navigator.mediaDevices.getUserMedia({audio: true, video: true});
	    console.log('got local stream');
	    localVideo.srcObject = stream;
	    localStream = stream;
        localStream.getTracks().forEach(track => peerconn.addTrack(track, localStream));
		peerconn.addEventListener('icecandidate', e => onIceCandidateEvent(e) );
		peerconn.addEventListener('iceconnectionstatechange', e => onIceStateChange(e, peerconn));

	  } catch (e) {
	    alert(`getUserMedia() error: ${e.name}`);
	  }
	}

	function onIceCandidateEvent(event) {
		console.log("sending ICE candidate event ", event.candidate);
		// bounce off server back to remote peer
		socket.emit("send-ice-candidate", {
			targetsocketid: remotesocketid,
			icecandidate: event.candidate
		});
	}

	function onIceStateChange(event, peerconnection) {
	    console.log(`ICE state: ${peerconnection.iceConnectionState}`);
	    console.log('ICE state change event: ', event);
	}

	startRTC();

	*/

</script>

</html>